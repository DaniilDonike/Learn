[[Web mining]]
Из датасетов аналитик извлекает информацию, фильтрует неправдоподобные данные и ищет общие элементы. Здесь в ход идёт мощный инструмент поиска строк — регулярные выражения.

**Регулярное выражение** — правило для поиска подстрок (фрагментов текста внутри строк). Например, если мы ищем сочетание букв «мя» в предложении «Вовремя подняли знамя и бросились в пламя», для Python это поиск подстроки `"мя"` в строке `'Вовремя подняли знамя и бросились в пламя'`.

## Как работают регулярные выражения

Для работы с регулярными выражениями в Python импортируют библиотеку **re** (от англ. _regular expressions_ — «регулярные выражения»). Дальше поиск ведётся в два этапа.

Сначала создают шаблон регулярного выражения. Это алгоритм, по которому нужно искать строку в тексте. Например: найти кириллические заглавные буквы «С».

Затем готовый шаблон передают специальным методам библиотеки _re_, которые ищут, заменяют и удаляют нужные символы. Таким образом, шаблон определяет, что и как искать, а метод — что с этим потом делать.

### **Основные шаблоны регулярных выражений**

В таблице приведены простейшие шаблоны регулярных выражений. Сложные регулярные выражения состоят из их комбинаций.

|Регулярное выражение|Описание|Пример|Пояснение|
|---|---|---|---|
|`[]`|Один из символов в скобках|`[a-]`|a или -|
|`[^…]`|Отрицание|`[^a]`|любой символ кроме «a»|
|`-`|Интервал|`[0-9]`|интервал: любая цифра от 0 до 9|
|`.`|Один любой символ, кроме перевода строки|`a.`|as, a1, a_|
|`\d` (аналог `[0-9]`)|Любая цифра|`a\d ǀ a[0-9]`|a1, a2, a3|

### Регулярные выражения в Python

Самые распространённые задачи аналитика:

- найти подстроку в строке,
- разбить строки на подстроки на основании шаблона,
- заменить части строки на другую строку.
    
    Вот какие методы библиотеки _re_ для этого понадобятся:
    

**search(pattern, string)** (англ. «поиск») ищет шаблон _pattern_ в строке _string._ Хотя _search()_ ищет шаблон во всей строке, возвращает он только первую найденную подстроку:

```python
import re
string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.search('\w+', string))

<re.Match object; span=(1, 8), match='Генерал'> 
```

Метод _search()_ возвращает объект типа **match** (англ. «соответствовать»). Параметр _span_ (англ. «диапазон») указывает диапазон индексов, подходящих под шаблон. В нашем случае открывающая кавычка `«` не отвечает правилу, которое игнорирует знаки препинания. Вот потому индексы идут с 1 по 8: от буквы «Г» до буквы «л». В параметре _match_ указано само значение подстроки.

Шаблону `'\w+'` соответствует любая подстрока, содержащая одну и более букв, цифр или символ нижнего подчёркивания _ . Метод _search()_ нашёл, что этому шаблону соответствует первое слово в строке. Так как под правило `'\w+'` не подходит пробел, метод вернул всё, что идёт до первого пробела.

Если нам не нужны дополнительные сведения о диапазоне, выведем только найденную подстроку методом _group()_: 

```python
import re

string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.search('\w+', string).group())

'Генерал' 
```

Как добыть информацию между определенными словами? Достанем данные, содержащие русские буквы или пробел между символами `"«"` и `"»"`

```python
import re

string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.search('«[А-Яа-яЁё ]+»', string).group())

'«Генерал Слокам»' 
```

Обратите внимание, что мы учли все символы, содержащиеся в нужной подстроке, в том числе — пробел.

**split(pattern, string)** (англ. «расщеплять, разбивать») разделяет строку _string_ по границе шаблона _pattern_.

Скопировать кодPYTHON

```
import re
string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.split('\d+', string))

['«Генерал Слокам» ', ' июня ', ' года Ист-Ривер Человеческий фактор'] 
```

Строка разделена на три части. Границы деления строки проходят там, где метод встретил указанный в аргументе шаблон. В нашем случае шаблону регулярного выражения `'\d+'` соответствует одна и более цифр. Поэтому строка поделилась натрое в тех местах, где _split()_ обнаружил подстроки из цифр — `15` и `1904`.

Количеством делений строки можно управлять. За это отвечает параметр **maxsplit** метода _split()_ (по умолчанию равен 0).

Скопировать кодPYTHON

```
import re
string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.split('\d+', string, maxsplit = 1))

['«Генерал Слокам» ', ' июня 1904 года Ист-Ривер Человеческий фактор'] 
```

Строка разделилась один раз по первому найденному шаблону.

**sub(pattern, repl, string)** (от англ. _substring_, «подстрока») ищет подстроку _pattern_ в строке _string_ и заменяет его на подстроку **repl** (от англ. _replace_ — «заменить»).

Скопировать кодPYTHON

```
import re
string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.sub('\d+', '', string)) # ищем числа
# и заменяем на пустоту

'«Генерал Слокам»  июня  года Ист-Ривер Человеческий фактор' 
```

Все подстроки с числами заменены на пустоту.

Метод **findall(pattern, string)** возвращает список _всех подстрок_ в _string_, удовлетворяющих шаблону _pattern._ А не только первую подходящую подстроку, как _search()_. Найдём все слова, заканчивающиеся на `"мя"`:

Скопировать кодPYTHON

```
import re

mya = "Вовремя подняли знамя и бросились в пламя"
print(re.findall('[А-Яа-яЁё]+мя', mya))

['Вовремя', 'знамя', 'пламя'] 
```

... или слова с дефисом:

Скопировать кодPYTHON

```
import re

string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(re.findall('\w+-\w+', string))

['Ист-Ривер'] 
```

Шаблон соответствует слову, содержащему «-», а такое в строке одно — это «Ист-Ривер». Метод **findall()** удобен тем, что можно сразу посчитать количество повторяющихся подстрок в строке функцией _len()_:

Скопировать кодPYTHON

```
import re

string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(len(re.findall('\w+', string)))

10 
```

Функция _len()_ вывела результат на единицу больше, чем мы ожидали. Так произошло, потому что слово «Ист-Ривер» разбилось на два слова, ведь «-» не подходит под шаблон `'\w+'`.

Добавим _`'-'`_ в шаблон регулярного выражения и учтем Ист-Ривер как одно слово.

Скопировать кодPYTHON

```
import re

string = "«Генерал Слокам» 15 июня 1904 года Ист-Ривер Человеческий фактор"
print(len(re.findall('[\w-]+', string)))

9 
```